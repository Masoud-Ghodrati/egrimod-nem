
# coding: utf-8

# # DCOPF Model of Australia's National Electricity Market
# A DCOPF model of Australia's National Electricity Market (NEM) is developed using the network and generator datasets previously constructed. The model takes into account the two AC grids that comprise the NEM, HVDC links, and limits on interconnector flows between regions. Nodal power injections from intermittent sources (wind and solar) are computed for each node using historic dispatch profiles for generators within the NEM, obtained from AEMO's MMSDM database [1]. These data are also used to compare dispatch signals generated by the model with realised market outcomes. 
# 
# MMSDM dispatch and load data for June 2017 are used as an example. Other periods can easily be analysed by loading MMSDM tables from different periods. The DCOPF model is solved for each 30 mininute trading interval for the month of June 2017 to demonstrate the capacity of these datasets to yield feasible models. Scenarios are then considered that seek to assess how well these datasets are able to emulate NEM operation. An overview of the scenarios explored are as follows:
# 
# ### Scenario 1
# This scenario is based on [2], whereby deviations between interconnector flows and model outcomes are minimised. The method used in [2] is extended by also considering generator output, and simultaneously seeking to minimise the differnce between model and observed dispatch. This scenario can help indicate if network or generator parameters have been misspecified e.g. interconnector flow limits.
# 
# ### Scenario 2
# Generator injections are fixed, and interconnector flow observed. This scenario gives an indication as to the influence that network parameters, such as the electrical properties of transmissions lines, interconnector limits, and the distribution of load has power flows. Large deviations between observed and models flows may indicate misspecification of these parameters.
# 
# ### Scenario 3
# A canonical generator cost minimisation objective is used in this scenario. Relative differences in generator short-run marginal costs (SRMCs) are expected to impact dispatch. This scenario helps assess how well these economic parameters are capture dispatch decisions of generators within the NEM.
# 
# ## Model construction protocol
# For each scenario, the model is solved for each trading interval within a 24hr period (48 trading intervals in total). The model is also run using a reduced network formulation for each scenario. This reduced model treats each NEM zone as a node, and neglects transmission line electrical parameters and node voltage angles. Using this network allows the additional informational content of the full network representation to be assessed. Results from each scenario are stored in dataframes and dictionaries which are pickled and saved.
# 
# A summary of the steps taken to construct the DCOPF model is as follows:
# 1. Import pacakges, declare paths to files, and load data
# 2. Organise model data:
#     * summarise important parameters for each node (e.g. assigned DUIDs, NEM region, NEM zone, proportion of regional demand consumed at node);
#     * compute aggregate nodal power injections from intermittent sources at each node for each time interval.
# 5. Define reference nodes for the mainland and Tasmania
# 6. Construct admittance matrix for the network
# 7. Construct incidence matrix describing the connections of HVDC links
# 8. Construct DCOPF model
# 9. Solve DCOPF model for each time period and scenario under investigation

# ## Import packages

# In[1]:


import os
import pickle
from math import pi
import random

import numpy as np
import pandas as pd

from pyomo.environ import *
import matplotlib.pyplot as plt


# ## Declare paths to files

# In[2]:


class DirectoryPaths(object):
    "Paths to directories containing relevant data"
    
    def __init__(self):
        
        # Core data directory
        self.data_dir = os.path.abspath(os.path.join(os.path.curdir, os.path.pardir, os.path.pardir, 'data'))

        # Network directory
        self.network_dir = os.path.abspath(os.path.join(os.path.curdir, os.path.pardir, '1_network'))

        # Generators directory
        self.gens_dir = os.path.abspath(os.path.join(os.path.curdir, os.path.pardir, '2_generators'))

        # Signals directory
        self.signals_dir = os.path.abspath(os.path.join(os.path.curdir, os.path.pardir, '3_load_and_dispatch_signals'))

        # Output path
        self.output_dir = os.path.abspath(os.path.join(os.path.curdir, 'output'))
        
paths = DirectoryPaths()


# ##  Load data

# In[3]:


class ModelData(DirectoryPaths):
    
    def __init__(self):
        # Paths to relevant directories
        DirectoryPaths.__init__(self)
        

        # Network data
        # ------------
        # Nodes
        self.df_n = pd.read_csv(os.path.join(self.network_dir, 'output', 'network_nodes.csv'), index_col='NODE_ID', dtype={'NEAREST_NODE':np.int32})

        # Edges
        self.df_e = pd.read_csv(os.path.join(self.network_dir, 'output', 'network_edges.csv'), index_col='LINE_ID')

        # HVDC links
        self.df_hvdc = pd.read_csv(os.path.join(self.network_dir, 'output', 'network_hvdc_links.csv'), index_col='HVDC_LINK_ID')

        # AC interconnector links
        self.df_ac_i = pd.read_csv(os.path.join(self.network_dir, 'output', 'network_ac_interconnector_links.csv'), index_col='INTERCONNECTOR_ID')

        # AC interconnector flow limits
        self.df_ac_ilim = pd.read_csv(os.path.join(self.network_dir, 'output', 'network_ac_interconnector_flow_limits.csv'), index_col='INTERCONNECTOR_ID')
        
        # Power station - node assignments
        self.df_station_nodes = pd.read_csv(os.path.join(self.network_dir, 'output', 'network_power_stations-nodes.csv'), index_col='POWER_STATION_ID', dtype={'NEAREST_NODE':np.int32})


        # Generator data
        # --------------
        self.df_g = pd.read_csv(os.path.join(self.gens_dir, 'output', 'generators.csv'), dtype={'NODE': int}, index_col='DUID')


        # Dispatch and load signals
        # -------------------------
        # Dispatch signals from SCADA data
        self.df_scada = pd.read_csv(os.path.join(self.signals_dir, 'output', 'signals_dispatch.csv'), index_col='SETTLEMENTDATE', parse_dates=['SETTLEMENTDATE'])

        # Regional demand signals
        self.df_regd = pd.read_csv(os.path.join(self.signals_dir, 'output', 'signals_regional_load.csv'), index_col='SETTLEMENTDATE', parse_dates=['SETTLEMENTDATE'])


        # Interconnector flow data
        # ------------------------
        df_iflow = pd.read_csv(os.path.join(self.data_dir, 'AEMO', 'MMSDM', 'PUBLIC_DVD_TRADINGINTERCONNECT_201706010000.CSV'), engine='python', skiprows=1, skipfooter=1)
        df_iflow['SETTLEMENTDATE'] = pd.to_datetime(df_iflow['SETTLEMENTDATE'])
        self.df_iflow = df_iflow.pivot(index='SETTLEMENTDATE', columns='INTERCONNECTORID', values='MWFLOW')

        
        # Cross-reference tables
        # ----------------------
        # AEMO DUIDs - Geoscience Australia power station names
        self.df_duid_stations = pd.read_csv(os.path.join(self.data_dir, 'cross_reference', 'DUID-GA-POWER_STATIONS.csv'), index_col='DUID')


# ## Organise model data

# In[4]:


class OrganiseData(ModelData):
    "Organise data to be used in linear DCOPF model"
    
    def __init__(self):
        # Load model data
        ModelData.__init__(self)
        
        
    def get_intermittent_generation_profiles(self):
        "SCADA dispatch profiles for intermittent generators"
        
         # Add fuel category to each DUID in SCADA dispatch dataframe
        df = self.df_scada.T.join(self.df_g[['FUEL_CAT']])

        # Only consider intermittent solar and wind generators
        mask = df['FUEL_CAT'].isin(['Solar', 'Wind'])
        
        # Keep wind and solar DUIDs, drop fuel category column, and transpose (columns=DUID, index=Timestamp)
        return df[mask].drop('FUEL_CAT', axis=1).T      
        
        
    def get_nodal_intermittent_injections(self):
        "Fixed injections from intermittent sources (columns=node ID, index=Timestamps)"
        
        # All intermittent generation profiles
        df = self.get_intermittent_generation_profiles()

        # Add node to which generator is connected, groupby node and sum, 
        # reindex columns using all node IDs, yielding total intermittent injection at each node
        return df.T.join(self.df_g[['NODE']], how='left').groupby('NODE').sum().T.reindex(columns=self.df_n.index, fill_value=0)
    
    
    def get_zonal_intermittent_injections(self):
        "Fixed injections from intermittent sources for each NEM zone (columns=Zone ID, index=Timestamps"
        
        # All intermittent generation profiles
        df = self.get_intermittent_generation_profiles()

        # Add node to which generator is connected, groupby node and sum, 
        # reindex columns using unique zones, yielding total intermittent injection in each NEM zone
        return df.T.join(self.df_g[['NEM_ZONE']], how='left').groupby('NEM_ZONE').sum().T.reindex(columns=self.df_n['NEM_ZONE'].unique(), fill_value=0)
    
    
    def get_nodal_demand(self):
        "Demand at each node for each time period (columns=node IDs, index=Timestamps)"
        
        def _node_demand(row, df_regd):
            return row['PROP_REG_D'] * df_regd.loc[:, row['NEM_REGION']]
        
        return self.df_n.apply(_node_demand, args=(self.df_regd,), axis=1).T

    
    def get_zonal_demand(self):
        "Demand in each NEM zone for each time period (columns=NEM Zones, index=Timestamps)"
        
        df = self.get_nodal_demand()
        
        return df.T.join(self.df_n[['NEM_ZONE']], how='left').groupby('NEM_ZONE').sum().T
    
    
    def get_generators_at_node(self):
        "Generators connected to each node (index=Node ID, values=set of generators connected to node)"
        
        # Generators connected to each node
        s = self.df_g.reset_index().groupby('NODE')['DUID'].aggregate(lambda x: set(x))
        
        # Reindex so all node in network are included in series. If no generator at node, fill with empty set.
        s = s.reindex(self.df_n.index, fill_value=set())
        
        return s
    
    
    def get_generators_in_zone(self):
        "Generators in each NEM zone (index=NEM Zone, values=set of generators in NEM zone)"
        
        return self.df_g.reset_index().groupby('NEM_ZONE')['DUID'].aggregate(lambda x: set(x))
    
    
    def get_admittance_matrix(self):
        "Construct admittance matrix for network"

        # Initialise dataframe
        df_Y = pd.DataFrame(data=0j, index=self.df_n.index, columns=self.df_n.index)

        # Off-diagonal elements
        for index, row in self.df_e.iterrows():
            fn, tn = row['FROM_NODE'], row['TO_NODE']
            df_Y.loc[fn, tn] += - (1 / (row['R_PU'] + 1j * row['X_PU'])) * row['NUM_LINES']
            df_Y.loc[tn, fn] += - (1 / (row['R_PU'] + 1j * row['X_PU'])) * row['NUM_LINES']

        # Diagonal elements
        for i in self.df_n.index:
            df_Y.loc[i, i] = - df_Y.loc[i, :].sum()

        # Add shunt susceptance to diagonal elements
        for index, row in self.df_e.iterrows():
            fn, tn = row['FROM_NODE'], row['TO_NODE']
            df_Y.loc[fn, fn] += (row['B_PU'] / 2) * row['NUM_LINES']
            df_Y.loc[tn, tn] += (row['B_PU'] / 2) * row['NUM_LINES']

        return df_Y
    
    
    def get_reference_nodes(self):
        "Reference nodes for each AC grid"
        
        # Set mainland reference bus as Victoria's RRN
        mask_vic = (self.df_n['RRN'] == 1) & (self.df_n['STATE_NAME'] == 'Victoria')

        # Use Tasmania's RRN as the reference node for the island
        mask_tas = (self.df_n['RRN'] == 1) & (self.df_n['STATE_NAME'] == 'Tasmania')

        # List of reference nodes
        ref_nodes = [self.df_n.loc[mask_vic].index.values[0], self.df_n.loc[mask_tas].index.values[0]]
        
        return ref_nodes
    
    
    def get_full_network_HVDC_incidence_matrix(self):
        "Incidence matrix for full network HVDC links"
        
        # Incidence matrix for HVDC links
        df = pd.DataFrame(index=self.df_hvdc.index, columns=self.df_n.index, data=0)

        for index, row in self.df_hvdc.iterrows():
            # From nodes assigned a value of 1
            df.loc[index, row['FROM_NODE']] = 1

            # To nodes assigned a value of -1
            df.loc[index, row['TO_NODE']] = -1
        
        return df
    
    
    def get_reduced_network_HVDC_incidence_matrix(self):
        "Incidence matrix for reduced network HVDC links"
        
        # Incidence matrix for HVDC links
        df = pd.DataFrame(index=self.df_hvdc.index, columns=self.df_n['NEM_ZONE'].unique(), data=0)
       
        for index, row in self.df_hvdc.iterrows():
            # From zones assigned a value of 1, 'to' zones assigned a value of -1
            from_zone = self.df_n.loc[row['FROM_NODE'], 'NEM_ZONE']
            df.loc[index, from_zone] = 1

            # Correct 'to' zone for N-Q-MNSP1 (Terranora). Technically is NNS, but should be SEQ in model.
            to_zone = self.df_n.loc[row['TO_NODE'], 'NEM_ZONE']
            df.loc[index, to_zone] = -1
         
        # Find and drop any HVDC links that have not been allocated both 'to' and 'from' nodes
        # (DIRECTLINK should be dropped because both nodes are in NSW, and it technically isn't an interconnector as defined by AEMO)
        mask = df.sum(axis=1).abs() != 0
        drp = df.sum(axis=1).abs()[mask].index
        df = df.drop(drp)
        
        return df
    
    def get_reduced_network_AC_incidence_matrix(self):
        "Incidence matrix for AC links in the reduced network"    

        # Lines in the reduced network
        rn_lines = ['ADE,NSA', 'SESA,ADE', 'MEL,SESA', 'MEL,CVIC', 'MEL,LV', 'MEL,NVIC', 
                    'CVIC,SWNSW', 'NVIC,SWNSW', 'NVIC,CAN', 'CAN,SWNSW', 'CAN,NCEN', 
                    'NCEN,NNS', 'NNS,SWQ', 'SWQ,SEQ', 'SWQ,CQ', 'SEQ,CQ', 'CQ,NQ', 'NNS,SEQ']

        # Incidence matrix for network based on NEM zones as nodes
        df = pd.DataFrame(index=rn_lines, columns=self.df_n['NEM_ZONE'].unique(), data=0)

        for line in rn_lines:
            # Get 'from' and 'to' nodes for each line
            fn, tn = line.split(',')

            # Assign 'from' node value of 1
            df.loc[line, fn] = 1

            # Assign 'to' node value of -1
            df.loc[line, tn] = -1

        return df
    
    def get_scheduled_generators(self):
        "List of scheduled generators"
        
        mask = self.df_g['SCHEDULE_TYPE'] == 'SCHEDULED'
        
        return list(self.df_g[mask].index)
    
    def get_full_network_ac_interconnector_nodes(self, ac_interconnector_id, link_end):
        'Get all nodes connected to the "FROM" or "TO" end of an AC interconnector'
        
        if link_end not in ['FROM', 'TO']:
            raise(Exception('Link end specified must either be "FROM" or "TO"'))
        
        return data.df_ac_i.reset_index().groupby('INTERCONNECTOR_ID')['{0}_NODE'.format(link_end)].aggregate(lambda x: set(x)).loc[ac_interconnector_id]


# Instantiate class containing organised model data.

# In[5]:


# Organised model data
data = OrganiseData()

# Save admittance matrix
with open(os.path.join(paths.output_dir, 'df_Y.pickle'), 'wb') as f:
    pickle.dump(data.get_admittance_matrix(), f)


# ## Pyomo Model

# In[6]:


def construct_model(network_type):
    "Construct linear DCOPF model for full or reduced network"
    
    # Initialise model object
    # -----------------------
    m = ConcreteModel(name='DCOPF')


    # Sets
    # ----
    # Generators
    m.G = Set(initialize=data.get_scheduled_generators())

    # HVDC links
    m.H = Set(initialize=data.df_hvdc.index)
    
    # Set of HVDC interconnectors for which AEMO interconnector flow data is available
    m.E = Set(initialize=data.df_hvdc.index.drop('DIRECTLINK'))

    # AC Interconnectors
    m.I = Set(initialize=data.df_ac_ilim.index)
    
    
    if network_type == 'full':
        # Nodes in full network
        m.N = Set(initialize=data.df_n.index)

        # Full network HVDC incidence matrix
        df_HVDC_I_MAT = data.get_full_network_HVDC_incidence_matrix()

    elif network_type == 'reduced':  
        # Nodes in reduced network
        m.N = Set(initialize=data.df_n['NEM_ZONE'].unique())
        
        # Remove Directlink HVDC line (an intrazonal line only within NSW)
        m.H.remove('DIRECTLINK')
        
        # Reduced network HVDC incidence matrix
        df_HVDC_I_MAT = data.get_reduced_network_HVDC_incidence_matrix()

    else:
        raise(Exception('Must specify either "full" or "reduced" for network_type'))


    # Variables
    # ---------
    # Power output from generator
    def GENERATION_BOUNDS_RULE(m, g):
        return (0, data.df_g.loc[g, 'REG_CAP'])
    m.p = Var(m.G, bounds=GENERATION_BOUNDS_RULE)

    # HVDC flow
    def HVDC_FLOW_RULE(m, h):
        return (-data.df_hvdc.loc[h, 'REVERSE_LIMIT_MW'], data.df_hvdc.loc[h, 'FORWARD_LIMIT_MW'])
    m.h = Var(m.H, bounds=HVDC_FLOW_RULE)

    # Dummy variables used to minimise model and observed HVDC flow deviations over link
    m.DEV_HVDC_DUMMY_1 = Var(m.E, within=NonNegativeReals)
    m.DEV_HVDC_DUMMY_2 = Var(m.E, within=NonNegativeReals)

    # AC dummy variables used to minimise flow deviations over link
    m.DEV_AC_DUMMY_1 = Var(m.I, within=NonNegativeReals)
    m.DEV_AC_DUMMY_2 = Var(m.I, within=NonNegativeReals)

    # HVDC dummy variables used to compute absolute flow over link
    m.ABS_HVDC_DUMMY_1 = Var(m.H, within=NonNegativeReals)
    m.ABS_HVDC_DUMMY_2 = Var(m.H, within=NonNegativeReals)

    # AC dummy variables used to compute absolute flow over link
    m.ABS_AC_DUMMY_1 = Var(m.I, within=NonNegativeReals)
    m.ABS_AC_DUMMY_2 = Var(m.I, within=NonNegativeReals)
    
    # Power output dummy variables used to compute absolute difference between model and observed dispatch
    m.DEV_P_DUMMY_1 = Var(m.G, within=NonNegativeReals)
    m.DEV_P_DUMMY_2 = Var(m.G, within=NonNegativeReals)


    # Parameters
    # ----------
    # Observed AC interconnector flows
    m.AC_IFLOW = Param(m.I, mutable=True)

    # Cost coefficients for AC interconnector flows
    m.AC_IFLOW_COST = Param(m.I, mutable=True)

    # Observed HVDC interconnector flows
    m.HVDC_IFLOW = Param(m.E, mutable=True)

    # Cost coefficients for HVDC interconnector flows
    m.HVDC_IFLOW_COST = Param(m.H, mutable=True)

    # Observed dispatch for each generator
    m.P_OBS = Param(m.G, mutable=True)

    # Load
    m.DEMAND = Param(m.N, within=NonNegativeReals, mutable=True)

    # Intermittent generation - full network
    m.INTER = Param(m.N, mutable=True)

    # Short-run Marginal Costs
    def SRMC_RULE(m, g):
        return float(data.df_g.loc[g, 'SRMC_2016-17'])
    m.SRMC = Param(m.G, initialize=SRMC_RULE)

    # HVDC incidence matrix for full network
    def HVDC_I_MAT_RULE(m, h, n):
        return float(df_HVDC_I_MAT.loc[h, n])
    m.HVDC_I_MAT = Param(m.H, m.N, initialize=HVDC_I_MAT_RULE)


    if network_type == 'full':
        # Sets
        # ----
        # Reference nodes
        m.R = Set(initialize=data.get_reference_nodes())


        # Variables
        # ---------
        # Voltage angle
        def V_BOUNDS_RULE(m, n):
            return (-pi, pi)
        m.v = Var(m.N, bounds=V_BOUNDS_RULE)


        # Parameters
        # ----------
        # Admittance matrix
        df_Y = data.get_admittance_matrix()
        def B_RULE(m, n, o):
            return float(np.imag(df_Y.loc[n, o]))
        m.B = Param(m.N, m.N, initialize=B_RULE, mutable=True)

        # Voltage angle scaling factor (dummy parameter which can be updated)
        m.V_ANG_SCALE = Param(initialize=1/2, mutable=True)


        # Constraints
        # -----------
        # Power balance (at each node)
        def POWER_BALANCE_FULL_NETWORK_RULE(m, n):
            node_gens = data.get_generators_at_node().loc[n]
            if node_gens:
                return (sum(m.p[g] for g in node_gens if g in m.G) + m.INTER[n] - m.DEMAND[n] 
                        == 100 * sum(m.B[n, o] * (m.v[n] - m.v[o]) for o in m.N)
                        + sum(m.h[hvdc] * m.HVDC_I_MAT[hvdc, n] for hvdc in m.H))
            else:
                return (- sum(m.p[g] for g in node_gens if g in m.G) - m.INTER[n] + m.DEMAND[n] 
                        == - 100 * sum(m.B[n, o] * (m.v[n] - m.v[o]) for o in m.N)
                        - sum(m.h[hvdc] * m.HVDC_I_MAT[hvdc, n] for hvdc in m.H))
        m.POWER_BALANCE_FULL_NETWORK = Constraint(m.N, rule=POWER_BALANCE_FULL_NETWORK_RULE)

        # Voltage angle constraints (between connected nodes)
        def VOLTAGE_ANGLE_DIFFERENCE_RULE(m, n, o):
            if m.B[n, o] and (n != o):
                return m.v[n] - m.v[o] <= m.V_ANG_SCALE * pi
            else:
                return Constraint.Skip
        m.VOLTAGE_ANGLE_DIFFERENCE = Constraint(m.N, m.N, rule=VOLTAGE_ANGLE_DIFFERENCE_RULE)

        # Fix voltage angle to 0 at reference nodes
        def REFERENCE_VOLTAGE_ANGLE_RULE(m, r):
            return m.v[r] == 0
        m.REFERENCE_VOLTAGE_ANGLE = Constraint(m.R, rule=REFERENCE_VOLTAGE_ANGLE_RULE)

        # AC interconnector forward and reverse limits
        def INTERCONNECTOR_LIMIT_FULL_NETWORK_RULE(m, i):
            from_nodes = data.get_full_network_ac_interconnector_nodes(i, 'FROM')
            to_nodes = data.get_full_network_ac_interconnector_nodes(i, 'TO')
            return -data.df_ac_ilim.loc[i, 'REVERSE_LIMIT_MW'] <= sum(100 * m.B[f, t] * (m.v[f] - m.v[t]) for f in from_nodes for t in to_nodes) <= data.df_ac_ilim.loc[i, 'FORWARD_LIMIT_MW']
        m.INTERCONNECTOR_LIMIT_FULL_NETWORK = Constraint(m.I, rule=INTERCONNECTOR_LIMIT_FULL_NETWORK_RULE)

        # Compute flow deviation between model and observed AC interconnector flows
        def DEV_AC_INTERCONNECTOR_FLOW_LO_FULL_NETWORK_RULE(m, i):
            from_nodes = data.get_full_network_ac_interconnector_nodes(i, 'FROM')
            to_nodes = data.get_full_network_ac_interconnector_nodes(i, 'TO')
            return m.DEV_AC_DUMMY_1[i] >= sum(100 * m.B[f, t] * (m.v[f] - m.v[t]) for f in from_nodes for t in to_nodes) - m.AC_IFLOW[i]
        m.DEV_AC_INTERCONNECTOR_FLOW_LO_FULL_NETWORK = Constraint(m.I, rule=DEV_AC_INTERCONNECTOR_FLOW_LO_FULL_NETWORK_RULE)

        def DEV_AC_INTERCONNECTOR_FLOW_UP_FULL_NETWORK_RULE(m, i):
            from_nodes = data.get_full_network_ac_interconnector_nodes(i, 'FROM')
            to_nodes = data.get_full_network_ac_interconnector_nodes(i, 'TO')
            return m.DEV_AC_DUMMY_2[i] >= m.AC_IFLOW[i] - sum(100 * m.B[f, t] * (m.v[f] - m.v[t]) for f in from_nodes for t in to_nodes)
        m.DEV_AC_INTERCONNECTOR_FLOW_UP_FULL_NETWORK = Constraint(m.I, rule=DEV_AC_INTERCONNECTOR_FLOW_UP_FULL_NETWORK_RULE)

        # Compute absolute power flows over AC links in full network
        def ABS_AC_INTERCONNECTOR_FLOW_LO_FULL_NETWORK_RULE(m, i):
            from_nodes = data.get_full_network_ac_interconnector_nodes(i, 'FROM')
            to_nodes = data.get_full_network_ac_interconnector_nodes(i, 'TO')
            return m.ABS_AC_DUMMY_2[i] >= - sum(100 * m.B[f, t] * (m.v[f] - m.v[t]) for f in from_nodes for t in to_nodes)
        m.ABS_AC_INTERCONNECTOR_FLOW_LO_FULL_NETWORK = Constraint(m.I, rule=ABS_AC_INTERCONNECTOR_FLOW_LO_FULL_NETWORK_RULE)

        def ABS_AC_INTERCONNECTOR_FLOW_UP_FULL_NETWORK_RULE(m, i):
            from_nodes = data.get_full_network_ac_interconnector_nodes(i, 'FROM')
            to_nodes = data.get_full_network_ac_interconnector_nodes(i, 'TO')
            return m.ABS_AC_DUMMY_1[i] >= sum(100 * m.B[f, t] * (m.v[f] - m.v[t]) for f in from_nodes for t in to_nodes)
        m.ABS_AC_INTERCONNECTOR_FLOW_UP_FULL_NETWORK = Constraint(m.I, rule=ABS_AC_INTERCONNECTOR_FLOW_UP_FULL_NETWORK_RULE)


    elif network_type == 'reduced':
        # Map between AEMO AC interconnector IDs and reduced network link names
        reduced_network_ac_interconnectors = {'NSW1-QLD1': ['NNS,SWQ'], 'V-SA': ['MEL,SESA'],
                                              'N-Q-MNSP1': ['NNS,SEQ'], 'VIC1-NSW1': ['NVIC,CAN', 'NVIC,SWNSW', 'CVIC,SWNSW']}
        
        # Sets
        # ----
        # AC links
        m.A = Set(initialize=data.get_reduced_network_AC_incidence_matrix().index)


        # Variables
        # ---------
        # Flows over AC links (for reduced network)
        m.a = Var(m.A)


        # Parameters
        # ----------
        # AC incidence matrix for reduced network
        df_AC_I_MAT = data.get_reduced_network_AC_incidence_matrix()
        def AC_I_MAT_RULE(m, a, n):
            return float(df_AC_I_MAT.loc[a, n])
        m.AC_I_MAT = Param(m.A, m.N, initialize=AC_I_MAT_RULE)
        

        # Constraints
        # -----------
        # Power balance (for each zone)
        def POWER_BALANCE_REDUCED_NETWORK_RULE(m, n):
            zone_gens = data.df_g.reset_index().groupby('NEM_ZONE')['DUID'].aggregate(lambda x: set(x)).loc[n].intersection(m.G)
            if zone_gens:
                return (sum(m.p[g] for g in zone_gens) + m.INTER[n] - m.DEMAND[n] 
                        == sum(m.a[l] * m.AC_I_MAT[l, n] for l in m.A)
                        + sum(m.h[l] * m.HVDC_I_MAT[l, n] for l in m.H))
            else:
                return (- sum(m.p[g] for g in zone_gens) - m.INTER[n] + m.DEMAND[n] 
                        == - sum(m.a[l] * m.AC_I_MAT[l, n] for l in m.A)
                        - sum(m.h[l] * m.HVDC_I_MAT[l, n] for l in m.H))
        m.POWER_BALANCE_REDUCED_NETWORK = Constraint(m.N, rule=POWER_BALANCE_REDUCED_NETWORK_RULE)

        # Interconnector forward and reverse limits - reduced network
        def INTERCONNECTOR_LIMIT_REDUCED_NETWORK_RULE(m, i): 
            return -data.df_ac_ilim.loc[i, 'REVERSE_LIMIT_MW'] <= sum(m.a[j] for j in reduced_network_ac_interconnectors[i]) <= data.df_ac_ilim.loc[i, 'FORWARD_LIMIT_MW']
        m.INTERCONNECTOR_LIMIT_REDUCED_NETWORK = Constraint(m.I, rule=INTERCONNECTOR_LIMIT_REDUCED_NETWORK_RULE)

        # Compute flow deviation between model and observed AC interconnector flows
        def DEV_AC_INTERCONNECTOR_FLOW_LO_REDUCED_NETWORK_RULE(m, i):
            return m.DEV_AC_DUMMY_2[i] >= m.AC_IFLOW[i] -  sum(m.a[j] for j in reduced_network_ac_interconnectors[i])
        m.DEV_AC_INTERCONNECTOR_FLOW_LO_REDUCED_NETWORK = Constraint(m.I, rule=DEV_AC_INTERCONNECTOR_FLOW_LO_REDUCED_NETWORK_RULE)

        def DEV_AC_INTERCONNECTOR_FLOW_UP_REDUCED_NETWORK_RULE(m, i):
            return m.DEV_AC_DUMMY_1[i] >= sum(m.a[j] for j in reduced_network_ac_interconnectors[i]) - m.AC_IFLOW[i]
        m.DEV_AC_INTERCONNECTOR_FLOW_UP_REDUCED_NETWORK = Constraint(m.I, rule=DEV_AC_INTERCONNECTOR_FLOW_UP_REDUCED_NETWORK_RULE)

        # Compute absolute power flows over AC links in reduced network
        def ABS_AC_INTERCONNECTOR_FLOW_LO_REDUCED_NETWORK_RULE(m, i):
            return m.DEV_AC_DUMMY_2[i] >= - sum(m.a[j] for j in reduced_network_ac_interconnectors[i])
        m.ABS_AC_INTERCONNECTOR_FLOW_LO_REDUCED_NETWORK = Constraint(m.I, rule=ABS_AC_INTERCONNECTOR_FLOW_LO_REDUCED_NETWORK_RULE)

        def ABS_AC_INTERCONNECTOR_FLOW_UP_REDUCED_NETWORK_RULE(m, i):
            return m.ABS_AC_DUMMY_1[i] >= sum(m.a[j] for j in reduced_network_ac_interconnectors[i])
        m.ABS_AC_INTERCONNECTOR_FLOW_UP_REDUCED_NETWORK = Constraint(m.I, rule=ABS_AC_INTERCONNECTOR_FLOW_UP_REDUCED_NETWORK_RULE)

    # Compute deviation between model and observed flows over HVDC links 
    def DEV_HVDC_FLOW_LO_RULE(m, hvdc):
        return m.DEV_HVDC_DUMMY_2[hvdc] >= m.HVDC_IFLOW[hvdc] - m.h[hvdc]
    m.DEV_HVDC_FLOW_LO = Constraint(m.E, rule=DEV_HVDC_FLOW_LO_RULE)

    def DEV_HVDC_FLOW_UP_RULE(m, hvdc):
        return m.DEV_HVDC_DUMMY_1[hvdc] >= m.h[hvdc] - m.HVDC_IFLOW[hvdc]
    m.DEV_HVDC_FLOW_UP = Constraint(m.E, rule=DEV_HVDC_FLOW_UP_RULE)

    # Compute absolute flow over HVDC links 
    def ABS_HVDC_FLOW_LO_RULE(m, hvdc):
        return m.ABS_HVDC_DUMMY_2[hvdc] >= - m.h[hvdc]
    m.ABS_HVDC_FLOW_LO = Constraint(m.H, rule=ABS_HVDC_FLOW_LO_RULE)

    def ABS_HVDC_FLOW_UP_RULE(m, hvdc):
        return m.ABS_HVDC_DUMMY_1[hvdc] >= m.h[hvdc]
    m.ABS_HVDC_FLOW_UP = Constraint(m.H, rule=ABS_HVDC_FLOW_UP_RULE)
    
    # Compute deviation between model and observed dispatch for all generators
    def DEV_P_LO_RULE(m, g):
        return m.DEV_P_DUMMY_2[g] >= m.P_OBS[g] - m.p[g]
    m.DEV_P_LO = Constraint(m.G, rule=DEV_P_LO_RULE)
    
    def DEV_P_UP_RULE(m, g):
        return m.DEV_P_DUMMY_1[g] >= m.p[g] - m.P_OBS[g]
    m.DEV_P_UP = Constraint(m.G, rule=DEV_P_UP_RULE)


    # Objective functions
    # -------------------
    # Minimise deviation between model and observed interconnector flows
    def OBJECTIVE_MIN_FLOW_DEVIATION_RULE(m):
        return sum(m.DEV_HVDC_DUMMY_1[hvdc] + m.DEV_HVDC_DUMMY_2[hvdc] for hvdc in m.E) + sum(m.DEV_AC_DUMMY_1[i] + m.DEV_AC_DUMMY_2[i] for i in m.I)
    m.OBJECTIVE_MIN_FLOW_DEVIATION = Objective(rule=OBJECTIVE_MIN_FLOW_DEVIATION_RULE, sense=minimize)
    
    # Minimise deviations between model and observed interconnector flows and generator dispatch
    def OBJECTIVE_MIN_FLOW_AND_GEN_DISPATCH_DEVIATION_RULE(m):
        return sum(m.DEV_HVDC_DUMMY_1[hvdc] + m.DEV_HVDC_DUMMY_2[hvdc] for hvdc in m.E) + sum(m.DEV_AC_DUMMY_1[i] + m.DEV_AC_DUMMY_2[i] for i in m.I) + sum(m.DEV_P_DUMMY_1[g] + m.DEV_P_DUMMY_2[g] for g in m.G)
    m.OBJECTIVE_MIN_FLOW_AND_GEN_DISPATCH_DEVIATION = Objective(rule=OBJECTIVE_MIN_FLOW_AND_GEN_DISPATCH_DEVIATION_RULE, sense=minimize)
    
    # Minimise generation costs and penalise deviations between model and observed interconnector flows
    def OBJECTIVE_MIN_FLOW_DEVIATION_AND_GEN_COST_RULE(m):
        return sum(m.p[g] * m.SRMC[g] for g in m.G) + 100 * ( sum(m.DEV_HVDC_DUMMY_1[hvdc] + m.DEV_HVDC_DUMMY_2[hvdc] for hvdc in m.E) + sum(m.DEV_AC_DUMMY_1[i] + m.DEV_AC_DUMMY_2[i] for i in m.I) )
    m.OBJECTIVE_MIN_FLOW_DEVIATION_AND_GEN_COST = Objective(rule=OBJECTIVE_MIN_FLOW_DEVIATION_AND_GEN_COST_RULE, sense=minimize)
   
    # Cost minimisation
    def OBJECTIVE_MIN_COST_RULE(m):
        return sum(m.p[g] * m.SRMC[g] for g in m.G) + sum(m.HVDC_IFLOW_COST[hvdc] * (m.ABS_HVDC_DUMMY_1[hvdc] + m.ABS_HVDC_DUMMY_2[hvdc]) for hvdc in m.H) + sum(m.AC_IFLOW_COST[i] * (m.ABS_AC_DUMMY_1[i] + m.ABS_AC_DUMMY_2[i]) for i in m.I)
    m.OBJECTIVE_MIN_COST = Objective(rule=OBJECTIVE_MIN_COST_RULE, sense=minimize)
    
    return m


# ### Function used to run model for different scenarios

# In[7]:


def run_model(date_range, network_type, mode):
    "Run model for a given network type and scenario"
    
    # Construct model
    model = construct_model(network_type)
    
    # Filename
    start_d = date_range[0].strftime('%Y-%m-%d_%H-%M-%S') # Start date
    end_d = date_range[-1].strftime('%Y-%m-%d_%H-%M-%S') # End date
    file_name = 'DCOPF_{0}_network_{1}_from_{2}_to_{3}.pickle'.format(network_type, mode, start_d, end_d)

    # Setup solver
    # ------------
    solver = 'gurobi'
    solver_io = 'lp'
    stream_solver = False
    keepfiles = False    
    model.dual = Suffix(direction=Suffix.IMPORT)
    opt = SolverFactory(solver, solver_io=solver_io)

    # Initialise voltage angle limit scaling factor
    model.V_ANG_SCALE = 1/2

    # Dictionary for DCOPF model results
    dcopf_results = {}

    # Deactivate all objectives by default
    model.OBJECTIVE_MIN_FLOW_DEVIATION.deactivate()
    model.OBJECTIVE_MIN_FLOW_DEVIATION_AND_GEN_COST.deactivate()
    model.OBJECTIVE_MIN_COST.deactivate()
    model.OBJECTIVE_MIN_FLOW_AND_GEN_DISPATCH_DEVIATION.deactivate()
    
    # Interconnector cost coefficients
    model.AC_IFLOW_COST['V-SA'] = 5
    model.AC_IFLOW_COST['NSW1-QLD1'] = 5
    model.AC_IFLOW_COST['VIC1-NSW1'] = 5
    model.AC_IFLOW_COST['N-Q-MNSP1'] = 5
    model.HVDC_IFLOW_COST['T-V-MNSP1'] = 5
    model.HVDC_IFLOW_COST['V-S-MNSP1'] = 5

    if network_type == 'full':
        # Directlink transmission cost coefficient
        model.HVDC_IFLOW_COST['DIRECTLINK'] = 5
        
        # Nodal demand
        df_full_network_nodal_demand = data.get_nodal_demand()

        # Nodal intermittent power injections
        df_full_network_intermittent_injections = data.get_nodal_intermittent_injections()

    elif network_type == 'reduced':
        # Zonal demand
        df_reduced_network_zonal_demand = data.get_zonal_demand()

        # Zonal intermittent power injections
        df_reduced_network_intermittent_injections = data.get_zonal_intermittent_injections()

    else:
        raise(Exception('Must specify either "full" or "reduced" for network_type'))

    # Solve model for each time stamp
    for t in date_range: 
        # Observed AC interconnector flows
        for i in model.I:
            model.AC_IFLOW[i] = float(data.df_iflow.loc[t, i])

        # Observed HVDC interconnector flows
        for e in model.E:
            model.HVDC_IFLOW[e] = float(data.df_iflow.loc[t, e])
            
        # Dispatch for each generator
        for g in model.G:
            model.P_OBS[g] = float(data.df_scada.loc[t, g])

        for n in model.N:
            if network_type == 'full':
                model.DEMAND[n] = float(df_full_network_nodal_demand.loc[t, n])
                model.INTER[n] = float(df_full_network_intermittent_injections.loc[t, n])
            elif network_type == 'reduced':
                model.DEMAND[n] = float(df_reduced_network_zonal_demand.loc[t, n])
                model.INTER[n] = float(df_reduced_network_intermittent_injections.loc[t, n])


        # Minimise deviation between model and observed flow, allowing generator output to be variable
        if mode is 'flow_dev_min':
            # Activate objective seeking to minimise difference between model and observed interconnector flows
            model.OBJECTIVE_MIN_FLOW_DEVIATION.activate()
            
        elif mode is 'flow_gen_dev_min':
            # Activate objective seeking to minimise difference between model and observed interconnector flows and generator output
            model.OBJECTIVE_MIN_FLOW_AND_GEN_DISPATCH_DEVIATION.activate()
            
        elif mode is 'min_flow_dev_and_gen_cost':
            # Activate objective seeking to minimise generation costs and difference between model and observed interconnector flows
            model.OBJECTIVE_MIN_FLOW_DEVIATION_AND_GEN_COST.activate()


        # Fix generator output and apply a charge to cross-border flows
        elif mode is 'fixed_gen':
            # Activate cost minimisation objective
            model.OBJECTIVE_MIN_COST.activate()

            # Fix output of all generators
            for g in data.df_g.index.intersection(model.G):
                model.p[g].fix(data.df_scada.loc[t, g])

            # Scale generator output such that total generation = total demand
            total_generation = sum(model.p[g].value for g in model.G) + sum(model.INTER[n].value for n in model.N)
            total_demand = sum(model.DEMAND[n].value for n in model.N)
            scaling_factor = total_demand / total_generation

            # Scale output from dispatchable generators
            updated_total_generation = 0
            for g in data.df_g.index.intersection(model.G):
                original = model.p[g].value
                scaled = original * scaling_factor
                model.p[g].fix(scaled)
                updated_total_generation += scaled

            # Scale intermittent injections at each node
            for n in model.N:
                original = model.INTER[n].value
                scaled = original * scaling_factor
                model.INTER[n] = scaled
                updated_total_generation += scaled

            # Print total generation and total demand as a check
            print('Total demand: {0}, Total generation: {1}'.format(total_demand, updated_total_generation))


        # Fix hydro output, but allow variable output from thermal generators
        elif mode is 'fixed_hydro':
            # Activate cost minimisation objective
            model.OBJECTIVE_MIN_COST.activate()

            # Fix output of hydro generators
            mask = data.df_g['FUEL_CAT'] == 'Hydro'
            for g in data.df_g[mask].index.intersection(model.G):
                model.p[g].fix(data.df_scada.loc[t, g])

        # Allow all generator output to be variable
        elif mode is 'free_gen':
            # Activate cost minimisation objective
            model.OBJECTIVE_MIN_COST.activate()  

        # Solve model
        r_dcopf = opt.solve(model, keepfiles=keepfiles, tee=stream_solver)
        
        # Place results in dictionary
        model.solutions.store_to(r_dcopf)
        dcopf_results[t] = r_dcopf
        
        # Store parameters for specified models
        if mode is 'fixed_gen':
            for n in model.N:
                dcopf_results[t]['Solution'][0]['Variable']['DEMAND[{0}]'.format(n)] = {'Value': model.DEMAND[n].value}
                dcopf_results[t]['Solution'][0]['Variable']['INTER[{0}]'.format(n)] = {'Value': model.INTER[n].value}
                
            for g in model.G:
                dcopf_results[t]['Solution'][0]['Variable']['p[{0}]'.format(g)] = {'Value': model.p[g].value}

        print(file_name, ': Finished period:', t)

    # Pickle and save to file
    with open(os.path.join(paths.output_dir, file_name), 'wb') as f:
        pickle.dump(dcopf_results, f)


# ## Run and solve model for differenent scenarios

# In[8]:


# Run model for all time periods in dataset (1 month)
# ---------------------------------------------------
start = '2017-06-01 00:30:00'
end = '2017-07-01 00:00:00'
date_range = pd.date_range(start, end, freq='30T')

run_model(date_range, network_type='full', mode='free_gen')
run_model(date_range, network_type='reduced', mode='free_gen')


# Run model for one day (48 trading intervals)
# --------------------------------------------
start = '2017-06-01 00:30:00'
date_range = pd.date_range(start, periods=48, freq='30T')


# All scenarios
# -------------
for network_type in ['full', 'reduced']:
    for mode in ['flow_gen_dev_min', 'fixed_gen', 'fixed_hydro', 'free_gen', 'min_flow_dev_and_gen_cost']:
        run_model(date_range, network_type=network_type, mode=mode)


# Specific scenarios
# ------------------
# run_model(date_range, network_type='full', mode='flow_gen_dev_min')
# run_model(date_range, network_type='reduced', mode='flow_gen_dev_min')
# run_model(date_range, network_type='full', mode='fixed_gen')


# ## References
# [1] - Australian Energy Market Operator. Data Archive (2018). at http://www.nemweb.com.au/#mms-data-model
# 
# [2] - Zhou, Q. & Bialek, J. W., Approximate model of european interconnected system as a benchmark system to study eﬀects of cross-border trades. IEEE Trans. Power Syst. 20, 782–788 (2005).
